<!doctype html>
<html lang="fr" id="top">

  <head>
    <meta charset="UTF-8">
    <meta name="google-site-verification" content="bug4GPSDEqxoKku92DUfj_WE6b8PlwHJX-DCeZZBV1w" />
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
              j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
     'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
          })(window,document,'script','dataLayer','GTM-MCT7LV9P');</script>
    <!-- End Google Tag Manager -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Flask - Chapitre 3 : Bases de données relationnelles avec SQLAlchemy - RB webstudio </title>

    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">

    <link rel="stylesheet" href="/static/styles-B-VF1A8o.css">

    <style>
      html.is-changing .transition-fade {
        transition: opacity 0.4s, filter .4s, transform .4s;
        opacity: 1;
        filter: blur(0px);
        transform: translateY(0);
      }

      html.is-animating .transition-fade {
        opacity: 0;
        filter: blur(0px);
        transform: translateY(-5rem);
      }
      html.is-changing :is(.layer, #lateralBar){
        opacity: 0 !important;
        visibility: hidden !important;
        #transition: none !important;#}
      }
      html.is-animating :is(.layer, #lateralBar){
        opacity: 0 !important;
        visibility: hidden !important;
        
      }
    </style>
    <meta name="description"  content="bla">
  </head>

  <body>
    <main class="grid-container" id="viewsTransition">
      <header class="flex-container align-justify align-middle">
    
    <div><a href="/">
  <svg id="logo" width="5rem" height="5rem" version="1.1" viewBox="0 0 79.375 79.375">
    <desc>RB webstudio - spécialiste Python - Javascript/Typescript</desc>
    <g transform="translate(-57.558 -71.836)">
    <circle cx="97.246" cy="111.52" r="33.073" fill="var(--color-cannes)" stroke-width=".177" style="paint-order:markers fill stroke"/>
    <g transform="matrix(.33371 0 0 .33371 -78.371 192.62)" fill="var(--color-laval)">
    <g transform="translate(243.55 81.615)" stroke-width=".67039" aria-label="rb">
    <path d="m251.15-309.59v27.653h-25.077v-31.927q0-10.81 2.0112-16.843 2.0112-6.0963 6.8505-10.81 3.6452-3.6452 8.4846-5.6564 4.9022-2.074 9.8044-2.074 2.3882 0 4.7136 0.18855 2.3254 0.18854 4.5251 0.56563v26.396q-0.43994-0.0628-1.3198-0.18855-2.074-0.31424-2.6396-0.31424-4.0852 0-5.7192 2.6396-1.6341 2.6396-1.6341 10.37z"/>
    <path d="m270.76-373.69h24.448v51.599q0 9.553 2.2626 13.324t7.5418 3.7709q3.8338 0 6.662-2.8282 2.8282-2.891 2.8282-6.7876 0-4.2109-2.7653-7.039-2.7653-2.891-6.7248-2.891-1.0056 0-2.1368 0.31425-1.1313 0.25139-3.2681 1.1313v-26.019q0.62849-0.0629 2.6396-0.18855 2.0112-0.18855 3.1424-0.18855 14.141 0 24.008 10.181 9.9301 10.119 9.9301 24.7 0 6.8505-2.514 13.135-2.5139 6.222-7.2276 11.061-4.9022 4.965-11.187 7.6675-6.222 2.6396-13.135 2.6396-10.181 0-18.415-5.2164-8.1703-5.2793-12.13-14.267-2.074-4.7765-3.0167-9.8672-0.94273-5.1536-0.94273-12.758v-4.9022z"/>
    </g>
    <path d="m542.38-288.15h-31.744l15.872-17.36z" stroke-width=".44511" style="paint-order:markers fill stroke"/>
    </g>
    </g>
  </svg>
</a></div>
    
    <nav class="flex-container align-right">
      <a href="/articles/index.html" class="margin-horizontal-1">articles</a>
      <a href="#contact" class="margin-horizontal-1">contact</a>
    </nav>
</header>

      
<progress id="progressTrue" max="100" value="0"></progress>
  <section>
    <article>
      <h1>Flask - Chapitre 3 : Bases de données relationnelles avec SQLAlchemy</h1>
      <div class="grid-x grid-padding-x">
        <ul class="cell medium-6 small-12 flex-container no-bullet tags-list">
          
            <li><a href="/articles/chercher-articles-par-python.html"><span>python</span></a></li>
          
            <li><a href="/articles/chercher-articles-par-developpement.html"><span>développement</span></a></li>
          
            <li><a href="/articles/chercher-articles-par-flask.html"><span>flask</span></a></li>
          
            <li><a href="/articles/chercher-articles-par-sqlalchemy.html"><span>SQLAlchemy</span></a></li>
          
        </ul>
        <nav aria-label="Partage de l’article sur les réseaux sociaux" class="cell medium-6 small-12">
          <ul class="flex-container no-bullet share">
            
              <li><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html&amp;title=Flask%20-%20Chapitre%203%20%3A%20Bases%20de%20donn%C3%A9es%20relationnelles%20avec%20SQLAlchemy&amp;source=http%3A//rb-webstudio.go.yj.fr" class="fa-brands fa-linkedin" target="_blank" rel="noopener noreferrer"><span>Partager sur Linkedin</span></a></li>
            
              <li><a href="https://twitter.com/intent/tweet?url=http%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html&amp;text=Flask%20-%20Chapitre%203%20%3A%20Bases%20de%20donn%C3%A9es%20relationnelles%20avec%20SQLAlchemy" class="fa-brands fa-square-x-twitter" target="_blank" rel="noopener noreferrer"><span>Partager sur Twitter</span></a></li>
            
              <li><a href="https://www.facebook.com/sharer/sharer.php?u=http%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html" class="fa-brands fa-square-facebook" target="_blank" rel="noopener noreferrer"><span>Partager sur Facebook</span></a></li>
            
              <li><a href="mailto:?subject=Je%20souhaite%20te%20partager%20cet%20article%20%3A%20Flask%20-%20Chapitre%203%20%3A%20Bases%20de%20donn%C3%A9es%20relationnelles%20avec%20SQLAlchemy&amp;body=Salut%2C%0AJe%20pense%20que%20cet%20article%20devrait%20t%27int%C3%A9resser%20%3A%0Ahttps%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html" class="fa-solid fa-square-share-nodes" target="_blank" rel="noopener noreferrer"><span>Partager à un ami</span></a></li>
            
          </ul>
        </nav>
      </div>
      <div class="content"><p>Les bases de données relationnelles constituent la pierre angulaire sur laquelle repose presque toute application Web moderne. Apprendre à concevoir votre application en termes de tables et de relations est l'une des clés d’un projet propre et bien structuré. Comme vous le verrez dans ce chapitre, le modèle de données que vous choisirez dès le départ influencera presque tous les aspects du code qui suivra. Nous utiliserons SQLAlchemy, un puissant <abbr><a href="#def-orm">ORM</a></abbr> qui nous permet d’abstraire la complexité des différents moteurs de bases de données afin de travailler directement avec la base depuis Python.</p>
<p><span id="def-orm"><strong>Remarque</strong>: Un mapping objet-relationnel (en anglais Object-Relational Mapping ou ORM) est un type de programme informatique qui se place en interface entre un programme applicatif et une base de données relationnelle pour simuler une base de données orientée objet. Ce programme définit des correspondances entre les schémas de la base de données et les classes du programme applicatif. On pourrait le désigner par là « comme une couche d'abstraction entre le monde objet et monde relationnel ». Du fait de sa fonction, on retrouve ce type de programme dans un grand nombre de frameworks sous la forme de composant ORM qui a été soit développé, soit intégré depuis une solution externe. <span></p>
<h2>Pourquoi utiliser une base de données relationnelle ?</h2>
<p>La base de données de votre application est bien plus qu’un simple registre de ce qu’il faut conserver pour un usage ultérieur. Si votre seul besoin était de sauvegarder et de récupérer des données, vous pourriez facilement utiliser des fichiers texte plats. Cependant, vous souhaitez pouvoir effectuer des requêtes intéressantes sur vos données. Et vous souhaitez le faire de manière efficace, sans réinventer la roue. Bien que les bases de données non relationnelles (parfois appelées bases NoSQL) soient très populaires et aient leur place dans l’univers du Web, les bases de données relationnelles ont depuis longtemps résolu les problèmes courants de filtrage, de tri, d’agrégation et de jointure de données tabulaires. Elles permettent de définir des ensembles de données de manière structurée tout en maintenant la cohérence des informations. En utilisant des bases de données relationnelles, vous vous donnez aussi, en tant que développeur, la liberté de vous concentrer sur les parties de votre application qui comptent vraiment.</p>
<p>En plus de permettre l’exécution efficace de requêtes ponctuelles, un serveur de base de données relationnelle vous offre également les avantages suivants :</p>
<ul>
<li>Il garantit que vos données respectent les règles définies dans le schéma ;</li>
<li>Il permet à plusieurs personnes d’accéder à la base de données simultanément, tout en assurant la cohérence des données sous-jacentes ;</li>
<li>Il s’assure que les données, une fois enregistrées, ne soient pas perdues même en cas de plantage de l’application.</li>
</ul>
<p>Les bases de données relationnelles et SQL, le langage de programmation utilisé avec ces bases, sont des sujets qui mériteraient à eux seuls un ouvrage complet. Cependant, comme ce tutoriel est consacré à l’apprentissage du développement d’applications avec Flask, je vais vous montrer comment utiliser un outil largement adopté par la communauté Python pour travailler avec des bases de données : <a href="https://www.sqlalchemy.org/" target="_blank">SQLAlchemy</a>.</p>
<p><strong>Important</strong> : <a href="https://www.sqlalchemy.org/" target="_blank">SQLAlchemy</a> masque de nombreuses complications liées à l’écriture de requêtes SQL, mais rien ne remplace une compréhension approfondie de SQL et du modèle relationnel. ’est pourquoi, si vous débutez avec SQL, je vous recommande vivement d'apprendre d'abord le SQL. </p>
<h2>Introduction à SQLAlchemy</h2>
<p>SQLAlchemy est une bibliothèque extrêmement puissante pour travailler avec des bases de données relationnelles en Python. Plutôt que d’écrire manuellement des requêtes SQL, vous pouvez utiliser des objets Python classiques pour représenter les tables de la base de données et exécuter des requêtes. Cette approche présente plusieurs avantages :</p>
<ul>
<li>Votre application peut être entièrement développée en Python.</li>
<li>Les différences subtiles entre les moteurs de bases de données sont masquées. Cela vous permet, par exemple, d’utiliser une base légère comme SQLite pour le développement et les tests locaux, puis de passer à une base conçue pour de fortes charges (comme PostgreSQL) en production.</li>
<li>Les erreurs liées à la base de données sont moins fréquentes, car deux couches s’interposent entre votre application et le serveur de base : l’interpréteur Python lui-même (qui intercepte les erreurs de syntaxe évidentes) et SQLAlchemy, qui dispose d’API bien définies et de son propre système de vérification des erreurs.</li>
<li>Votre code de gestion des données peut devenir plus efficace grâce au modèle de « unit of work » de SQLAlchemy, qui réduit les allers-retours inutiles avec la base. SQLAlchemy propose également des mécanismes de préchargement efficace des objets liés, appelés « eager loading ».</li>
<li>Le mappage objet-relationnel (ORM) rend votre code plus maintenable, conformément au principe « ne vous répétez pas » (DRY). Par exemple, si vous ajoutez une colonne à un modèle, celle-ci sera disponible partout où vous utilisez ce modèle. À l’inverse, si vous aviez disséminé des requêtes SQL écrites à la main dans toute votre application, vous devriez modifier chacune d’elles individuellement pour y inclure la nouvelle colonne.</li>
<li>SQLAlchemy peut vous aider à éviter les vulnérabilités liées aux injections SQL.</li>
<li>Excellente compatibilité avec d’autres bibliothèques : comme vous le verrez dans les chapitres suivants, de nombreuses bibliothèques utiles peuvent interagir directement avec vos modèles SQLAlchemy pour offrir des interfaces de maintenance ou des API RESTful, par exemple.</li>
</ul>
<p>J’espère que cette liste vous enthousiasme. Si certains points ne vous sont pas encore clairs, ne vous inquiétez pas : au fil de ce chapitre et des suivants, ces avantages deviendront plus concrets et significatifs. Maintenant que nous avons abordé les bénéfices de SQLAlchemy, installons-le et commençons à coder.</p>
<h3>Installer SQLAlchmy</h3>
<p>Nous utiliserons <code>pip</code> pour installer SQLAlchemy dans l'environnement virtuel de l'application blog. Comme vous l'avez vu dans le chapitre précédent, pour activer votre environnement virtuel, modifiez les répertoires source du script d'activation comme suit :</p>
<pre><code class="language-bash">$ cd ~/projects
$ source .venv/bin/activate
(.venv) ... $ pip install sqlalchemy
</code></pre>
<p>Vous pouvez vérifier si votre installation a réussi en ouvrant un interpréteur Python et en vérifiant la version de SQLAlchemy ; notez que votre numéro de version exact risque de différer.</p>
<pre><code class="language-bash">$ python
&gt;&gt;&gt; import sqlalchemy
&gt;&gt;&gt; sqlalchmy.__version__
'2.0.41'
</code></pre>
<h3>Utiliser SQLAlchemy dans notre application Flask</h3>
<p>SQLAlchemy fonctionne très bien avec Flask seul, mais l'auteur de Flask a publié une extension spéciale appelée Flask-SQLAlchemy qui fournit des aides pour de nombreuses tâches courantes et peut nous éviter de réinventer la roue plus tard. Utilisons pip pour installer cette extension :</p>
<pre><code class="language-bash">(.venv) $ pip install flask-sqlalchemy
</code></pre>
<p>Flask fournit une interface standard pour les développeurs souhaitant créer des extensions. Avec la popularité croissante du framework, le nombre d'extensions de haute qualité a augmenté. Si vous souhaitez consulter certaines des extensions les plus populaires, une liste triée est disponible sur le site web du projet Flask à l'adresse <a href="http://flask.pocoo.org/extensions/" target="_blank">http://flask.pocoo.org/extensions/</a>.</p>
<h3>Choisir le moteur de base de données</h3>
<p>SQLAlchemy prend en charge une multitude de dialectes de bases de données populaires, notamment SQLite, MySQL et PostgreSQL. Selon la base de données que vous souhaitez utiliser, vous devrez peut-être installer un package Python supplémentaire contenant un pilote de base de données. Voici plusieurs bases de données populaires prises en charge par SQLAlchemy et leurs pilotes installables via <code>pip</code>. Certaines bases de données proposent plusieurs options de pilotes, j'ai donc listé les plus populaires en premier.</p>
<table id="table-1">
    <caption>Drivers SQLAlchemy par système de gestion de base de données (SGBD) – Packages Python recommandés pour chaque dialecte</caption>
    <thead>
        <tr>
            <th scope="col">Base de données</th>
            <th scope="col">Driver</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>SQLite</td>
            <td>Non nécessaire, fait partie de la bibliothèque standard de Python depuis la version 2.5.</td>
        </tr>
        <tr>
            <td>MySQL</td>
            <td>MySQL-python, PyMySQL (pure Python), OurSQL</td>
        </tr>
        <tr>
            <td>PostgreSQL</td>
            <td>psycopg2-binary</td>
        </tr>
        <tr>
            <td>Firebird</td>
            <td>fdb</td>
        </tr>
        <tr>
            <td>SQL Server</td>
            <td>pymssql, PyODBC</td>
        </tr>
        <tr>
            <td>Oracle</td>
            <td>cx-Oracle</td>
        </tr>
    </tbody>
</table>

<p>SQLite est fourni par défaut avec Python et ne nécessite pas de processus serveur séparé, ce qui le rend parfait pour démarrer rapidement. Par souci de simplicité dans les exemples suivants, je montrerai comment configurer l'application de blog pour l'utiliser avec SQLite. Si vous préférez utiliser une autre base de données pour votre projet de blog, n'hésitez pas à installer dès maintenant le package du pilote nécessaire via <code>pip</code>.</p>
<h3>Se connecter à une base de données</h3>
<p>Ouvrez le module <code>config.py</code> de notre projet blog (<code>~/projects/blog/app/config.py</code>) avec votre éditeur de texte préféré. Nous allons ajouter un paramètre spécifique à SQLAlchemy pour indiquer à Flask-SQLAlchemy comment se connecter à notre base de données. Les nouvelles lignes sont mises en évidence ci-dessous :</p>
<pre><code class="language-python">from pathlib import Path

class Configuration(object):
    APPLICATION_DIR = Path(__file__).resolve().parent
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = f'sqlite:///{APPLICATION_DIR}/blog.db'
</code></pre>
<p><code>SQLALCHEMY_DATABASE_URI</code> se compose des éléments suivants :
<code>protocole+driver://username:password@host:port/database</code></p>
<p>Comme les bases de données SQLite sont stockées dans des fichiers locaux, la seule information à fournir est le chemin vers le fichier de base de données. En revanche, pour vous connecter à une instance PostgreSQL locale, votre URI ressemblerait plutôt à ceci :
<code>postgresql://postgres:secretpassword@localhost:5432/blog_db</code></p>
<p><strong>Remarque</strong> : Si vous rencontrez des difficultés pour vous connecter à votre base de données, consultez la documentation SQLAlchemy sur les URI de base de données : <a href="http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html." target="_blank">http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html</a>.</p>
<p>Maintenant que nous avons spécifié comment se connecter à la base de données, créons l'objet responsable de la gestion des connexions à notre base. Cet objet est fourni par l'extension <code>Flask-SQLAlchemy</code> et se nomme simplement <code>SQLAlchemy</code>. Ouvrez <code>app.py</code> et ajoutez les éléments suivants :</p>
<pre><code class="language-python">from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from config import Configuration


app = Flask(__name__)
app.config.from_object(Configuration)
db = SQLAlchemy(app)
</code></pre>
<p>Ces modifications configurent notre application Flask (et par extension SQLAlchemy) pour communiquer avec la base de données. L'étape suivante consiste à créer une table pour stocker les articles du blog, ce qui nécessitera la création de notre premier modèle.</p>
<h2>Création du modèle Entry</h2>
<p>Un modèle représente une table de données que nous souhaitons stocker dans la base de données. Ces modèles contiennent des attributs appelés colonnes qui représentent les éléments de données. Par exemple, pour un modèle <code>Person</code>, nous pourrions avoir des colonnes pour le prénom, le nom, la date de naissance, l'adresse, la couleur des cheveux, etc. Dans notre cas, comme nous créons un modèle pour des articles de blog, nous utiliserons des colonnes pour le titre, le contenu et autres champs pertinents.</p>
<p><strong>Remarque</strong>: on ne dit pas un modèle 'People' ou 'Entries' - <strong>les modèles sont toujours au singulier</strong> même s'ils représentent généralement plusieurs objets différents.</p>
<p>Avec SQLAlchemy, créer un modèle est aussi simple que de définir une classe et de lui attribuer différents champs. Commençons par un modèle très basique pour nos articles de blog. Créez un nouveau fichier nommé <code>models.py</code> dans le répertoire <code>app/</code> du projet blog, puis ajoutez le code suivant :</p>
<pre><code class="language-python">import datetime
import re
from app import db


def slugify(s):
    return re.sub('[^\w]+', '-', s).lower()


class Entry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    _title = db.Column('title', db.String(255))
    slug = db.Column(db.String(255), unique=True)
    body = db.Column(db.Text)
    created_timestamp = db.Column(db.DateTime, default=datetime.datetime.now)
    modified_timestamp = db.Column(db.DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)

    @property
    def title(self):
        return self._title

    @title.setter
    def title(self, value):
        self._title = value
        self.slug = slugify(value) if value else ''

    def __init__(self, *args, **kwargs):
        super(Entry, self).__init__(*args, **kwargs)
        if 'title' in kwargs:
            self.slug = slugify(kwargs['title'])
        else:
            self.slug = ''

    def __repr__(self):
        return '&lt;Entry: %r&gt;' % self.title
</code></pre>
<p>Plusieurs éléments sont à commenter. Commençons donc par les imports et détaillons progressivement. Nous importons d'abord les modules standards <code>datetime</code> et <code>re</code>. Le module <code>datetime</code> servira à obtenir la date/heure actuelle, tandis que <code>re</code> permettra des manipulations de chaînes. L'import suivant concerne l'objet <code>db</code> créé dans <code>app.py</code>. Comme vous vous en souvenez, <code>db</code> est une instance de la classe SQLAlchemy (fournie par Flask-SQLAlchemy) et donne accès aux classes nécessaires pour construire notre modèle <code>Entry</code>, que nous verrons sous peu. </p>
<p>Avant le modèle <code>Entry</code>, nous définissons une fonction utilitaire <code>slugify</code> pour générer des URLs conviviales (utilisées au Chapitre 4). Cette fonction transforme une chaîne comme <code>Un article sur Flask</code> en <code>un-article-sur-flask</code> via des expressions régulières. </p>
<p>Le modèle <code>Entry</code> lui-même est une classe héritant de <code>db.Model</code>, ce qui lui confère des helpers pour interroger la base de données. Ses attributs représentent la structure de la table : </p>
<ul>
<li><code>id</code> (clé primaire auto-générée), </li>
<li><code>title</code> (String(100) pour le titre), </li>
<li><code>slug</code> (String(100) unique pour l'URL), </li>
<li><code>body</code> (Text pour le contenu illimité), </li>
<li><code>created_timestamp</code> (DateTime rempli automatiquement à la création), </li>
<li><code>modified_timestamp</code> (DateTime mis à jour à chaque sauvegarde).</li>
</ul>
<p><strong>Remarque</strong> : Pour les chaînes courtes comme les titres ou noms, la colonne <code>String</code> est appropriée, mais pour les textes potentiellement longs, il est préférable d'utiliser une colonne <code>Text</code> comme nous l'avons fait pour le corps de l'article.</p>
<p>Nous avons surchargé le constructeur de la classe (<code>__init__</code>) pour qu'il génère automatiquement le slug à partir du titre lors de la création d'un nouveau modèle. </p>
<p>La dernière partie est la méthode <code>__repr__</code> qui produit une représentation lisible des instances de notre classe <code>Entry</code>. Bien que son fonctionnement exact ne soit pas crucial,  <code>__repr__</code> permet d'identifier facilement les objets lors du débogage. </p>
<p>Enfin, ajoutez les modifications indiquées dans <code>main.py</code> (point d'entrée de l'application) pour importer les modèles, comme suit :</p>
<pre><code class="language-python">from app import app, db
import models
import views


if __name__ == '__main__':
    app.run()
</code></pre>
<h3>Création de la table Entry</h3>
<p>Afin de commencer à travailler avec le modèle <code>Entry</code>, nous devons d'abord créer une table pour celui-ci dans notre base de données. Heureusement, Flask-SQLAlchemy propose un utilitaire pratique pour cela. créez un fichier nommé <code>create_db.py</code> :</p>
<pre><code class="language-bash">(.venv) $ cd app/
(.venv) $ touch script_create_db.py
</code></pre>
<p>Ajoutez le code suivant au module <code>create_db.py</code>. Cette fonction va automatiquement analyser tout le code que nous avons écrit et créer une nouvelle table dans notre base de données pour le modèle <code>Entry</code> basé sur nos modèles :</p>
<pre><code class="language-python">from main import db
from models import Entry
from app import app


with app.app_context():
    db.create_all()
</code></pre>
<p><strong>Important</strong> : L'appel à app.app_context() est important car certaines opérations avec Flask-SQLAlchemy nécessitent un contexte d'application actif. </p>
<p>Exécutez le script depuis le répertoire <code>app/</code>. Assurez-vous que l’environnement virtuel soit activé. Si tout se passe correctement, vous ne devriez voir aucune sortie.</p>
<pre><code class="language-bash">(.venv) $ python script_create_db.py
</code></pre>
<p><strong>Note</strong> : Si vous rencontrez des erreurs lors de la création des tables de la base de données, assurez-vous que vous vous trouvez dans le répertoire app et que l’environnement virtuel est activé lorsque vous exécutez le script. Vérifiez ensuite qu’il n’y a aucune faute de frappe dans votre paramètre SQLALCHEMY_DATABASE_URI.</p>
<h2>Travailler avec le modèle <code>Entry</code></h2>
<p>Expérimentons avec notre nouveau modèle <code>Entry</code> en enregistrant quelques articles de blog. Nous allons faire cela depuis le shell interactif de Python. À ce stade, installons IPython, un shell sophistiqué offrant des fonctionnalités telles que l’auto-complétion par tabulation (que le shell Python par défaut ne propose pas).</p>
<pre><code class="language-bash">(.venv) $ pip install ipython
</code></pre>
<p>Vérifiez maintenant que vous êtes dans le répertoire app, puis lançons le shell et créons quelques entrées comme suit :</p>
<pre><code class="language-bash">(.venv) $ ipython
In []: from models import *
In []: db
Out[]: &lt;SQLAlchemy&gt;
</code></pre>
<p><strong>Note</strong>: Si vous êtes familier avec le shell Python classique mais pas avec IPython, certaines choses peuvent vous paraître un peu différentes au début. L’élément principal à connaître est que <code>In[]</code> fait référence au code que vous saisissez, et <code>Out[]</code> correspond au résultat des commandes que vous entrez dans le shell.</p>
<p>IPython dispose d’une fonctionnalité pratique qui vous permet d’afficher des informations détaillées sur un objet. Pour cela, il suffit de taper le nom de l’objet suivi d’un point d’interrogation (?). L’inspection du modèle <code>Entry</code> fournit un certain nombre d’informations, notamment la signature des arguments et la chaîne représentant cet objet (appelée docstring) du constructeur.</p>
<pre><code class="language-bash">In []: Entry?
Init signature: Entry(*args, **kwargs)
Docstring:     
The base class of the :attr:`.SQLAlchemy.Model` declarative model class.

To define models, subclass :attr:`db.Model &lt;.SQLAlchemy.Model&gt;`, not this. To
customize ``db.Model``, subclass this and pass it as ``model_class`` to
:class:`.SQLAlchemy`. To customize ``db.Model`` at the metaclass level, pass an
already created declarative model class as ``model_class``.
File:           ~/projects/app/models.py
Type:           DefaultMeta
Subclasses: 
</code></pre>
<h3>Travailler avec IPython dans un contexte d'application Flask</h3>
<p>Créez un fichier nommé shell.py dans le dossier app. Dans ce fichier, ajoutez le code suivant :</p>
<pre><code class="language-python">from main import *
from models import *


with app.app_context():
    import IPython
    IPython.embed()
</code></pre>
<p>Désormais, lorsque vous souhaiterez utiliser IPython dans un environnement Flask, vous n’aurez plus besoin d'encapsuler vos requêtes dans <code>with app.app_context()</code>. Pour l’utiliser, il suffit d’exécuter :</p>
<pre><code class="language-bash">(.venv) $ python shell.py
</code></pre>
<p>Revenons à notre model <code>Entry.</code>Nous pouvons créer des objets <code>Entry</code> en passant les valeurs des colonnes sous forme d’arguments nommés. Dans l’exemple précédent, on utilise <code>**kwargs</code> ; il s’agit d’un raccourci permettant de prendre un objet de type dictionnaire et de l’utiliser comme valeurs pour définir l’objet, comme illustré ci-dessous. N'oubliez pas que vous devez être dans le contexte de <code>app</code> (<code>with app.app_context()</code>) :</p>
<pre><code class="language-bash">(.venv)$ python shell.py
In []: from main import app
In []: first_entry = Entry(title='premier article', body='contenu du premier article')
In []: db.session.add(first_entry)
In []: db.session.commit()
In []: db.session.refresh(first_entry)
</code></pre>
<p>La session est simplement un objet qui représente nos actions sur la base de données.. Pour enregistrer notre première entrée, nous devons l’ajouter à la session de base de données <code>db.session.add(first_entry)</code>. Pour l’enregistrer définitivement, nous devons valider la session (commit) <code>db.session.commit()</code>.  La méthode <code>refresh</code> permet de récuperer la ligne une fois enregistrer. Vous pouvez récupérer les données générées en base de données  :</p>
<pre><code class="language-bash">In []: first_entry.id
Out[]: 1
In []: first_entry.created_timestamp
Out[]: datetime.datetime(2025, 5, 25, 9, 49, 53, 1337)
</code></pre>
<p>Comme vous pouvez le voir dans les exemples de code précédents, une fois que vous validez la session, un identifiant unique sera attribué à votre première entrée et le champ <code>created_timestamp</code> sera défini à l’heure actuelle. Félicitations, vous avez créé votre premier article de blog ! N’hésitez pas à en ajouter plusieurs autres par vous-même. Vous pouvez ajouter plusieurs objets <code>Entry</code> à la même session avant de la valider, alors essayez aussi cette méthode.</p>
<p><strong>Note</strong>: À tout moment, pendant vos expérimentations, n’hésitez pas à supprimer le fichier <code>blog.db</code> puis à relancer le script <code>script_create_db.py</code> pour repartir avec une base de données toute neuve.</p>
<h3>Modifier une entrée existante</h3>
<p>Pour apporter des modifications à une entrée existante (<code>Entry</code>), il vous suffit d’effectuer les changements souhaités, puis de valider la session (commit). Récupérons notre entrée à l’aide de l’identifiant qui nous a été retourné précédemment, modifions-la, puis validons les changements. SQLAlchemy détectera automatiquement qu’une mise à jour est nécessaire.</p>
<p>Voici un exemple illustrant comment modifier la première entrée :</p>
<pre><code class="language-bash">In []: first_entry = Entry.query.get(1)
In []:  first_entry.title = &quot;changement du titre de l'article&quot;
In []:  db.session.commit()
</code></pre>
<p>Et voilà, vos modifications sont enregistrées.</p>
<p><strong>Astuce</strong> : Si vous souhaitez visualiser les données enregistrées dans votre base de données SQLite, vous pouvez utiliser un client graphique tel que <a href="http://sqlitebrowser.org" target="_blank">DB Browser for SQLite</a>.
Il vous suffit d’ouvrir le fichier <code>blog.db</code> (ou le nom de votre base) avec ce logiciel pour parcourir, modifier ou exporter vos données de manière visuelle.</p>
<h3>Supprimer une entrée</h3>
<p>Supprimer une entrée est tout aussi simple que d’en créer une. Au lieu d’appeler db.session.add, vous appellerez db.session.delete en passant l’instance de l’Entry que vous souhaitez supprimer.</p>
<pre><code class="language-bash">In []: second_entry = Entry()
In []: second_entry.title = &quot;un second titre&quot;
In []: second_entry.body = &quot;du contenu&quot;
In []: db.session.add(second_entry) # création d'une nouvelle entrée
In []: db.session.commit()
In []: to_delete = Entry.query.get(1) # la première ligne à supprimer id = 1
In []: db.session.delete(to_delete)
In []: db.session.commit()
</code></pre>
<h3>Récupération des articles de blog</h3>
<p>Bien que la création, la mise à jour et la suppression soient des opérations assez simples, le vrai plaisir commence lorsque nous examinons les différentes manières de récupérer nos articles. Nous allons commencer par les bases, puis progresser vers des requêtes plus intéressantes. Nous allons utiliser un attribut spécial sur notre classe de modèle pour effectuer les requêtes : <code>Entry.query</code>. Cet attribut expose une variété d’interfaces (APIs) permettant de travailler avec la collection d’articles dans la base de données.</p>
<p>Récupérons simplement une liste de toutes les entrées de la table <code>Entry</code> :</p>
<pre><code class="language-bash">In []: entries = Entry.query.all()
In []: entries
Out[]: [&lt;Entry: 'ttitre 1 '&gt;, &lt;Entry: 'titre 2'&gt;]
</code></pre>
<p>Comme vous pouvez le voir, dans cet exemple, la requête retourne une liste d’instances de <code>Entry</code> que nous avons créées.
Lorsque aucun ordre explicite n’est spécifié, les entrées nous sont renvoyées dans un ordre arbitraire défini par la base de données. Spécifions maintenant que nous souhaitons que les entrées nous soient renvoyées par ordre alphabétique, selon leur titre :</p>
<pre><code class="language-bash">In []: entries = Entry.query.order_by('title').all()
In []: entries
Out[]: [&lt;Entry: 'titre A'&gt;, &lt;Entry: 'titre B'&gt;]
</code></pre>
<p>Voici maintenant comment lister vos entrées par ordre chronologique inverse, en se basant sur leur date de dernière mise à jour :</p>
<pre><code class="language-bash">In []: from sqlalchemy import desc
In []: entries = Entry.query.order_by(desc('modified_timestamp')).all()
In []: entries
Out[]: [&lt;Entry: 'titre B'&gt;, &lt;Entry: 'titre A'&gt;]
</code></pre>
<h3>Filtrer la liste des articles</h3>
<p>Il est très utile de pouvoir récupérer l’ensemble des articles de blog, mais que faire si nous voulons filtrer cette liste ? Nous pourrions toujours récupérer toute la collection, puis la filtrer en Python à l’aide d’une boucle, mais ce serait très inefficace.</p>
<p>À la place, nous allons nous appuyer sur la base de données pour effectuer le filtrage, en spécifiant simplement les conditions que doivent remplir les entrées à retourner. Dans l’exemple suivant, nous allons spécifier que nous voulons filtrer les entrées dont le titre est égal à <code>First entry</code>.</p>
<pre><code class="language-bash">In []: entries = Entry.query.filter(Entry.title == 'titre B').all()
In []: entries
Out[]: [&lt;Entry: 'titre B'&gt;]
</code></pre>
<p>Si cela vous semble un peu magique, c’est parce que ça l’est vraiment ! SQLAlchemy utilise la surcharge d’opérateurs pour convertir des expressions telles que <code>&lt;Modèle&gt;.&lt;colonne&gt; == &lt;une valeur&gt;</code> en un objet abstrait appelé BinaryExpression.
Lorsque vous êtes prêt à exécuter votre requête, ces structures de données sont ensuite traduites en SQL.</p>
<p><strong>Note</strong> : Un BinaryExpression est tout simplement un objet qui représente une comparaison logique. Il est généré en surchargeant les méthodes standards généralement appelées sur un objet lors d’une comparaison de valeurs en Python.</p>
<p>Pour récupérer une seule entrée, vous avez deux options : <code>.first()</code> et <code>.one()</code>. Leurs différences et similitudes sont résumées dans le tableau suivant :</p>
<table>
    <caption>Comparaison des comportements des méthodes <code>.first()</code> et <code>.one()</code> en fonction du nombre de lignes retournées par la requête</caption>
    <thead>
        <tr>
            <th scope="col">Nombre de lignes correspondantes</th>
            <th scope="col">Comportement <code>.first()</code></th>
            <th scope="col">Comportement <code>.one()</code></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td><code>return object</code></td>
            <td><code>return object</code></td>
        </tr>
        <tr>
            <td>0</td>
            <td><code>return None</code></td>
            <td><code>Raise sqlalchemy.orm.exc.NoResultFound</code></td>
        </tr>
        <tr>
            <td>2+</td>
            <td><code>return object</code></td>
            <td><code>Raise sqlalchemy.orm.exc.MultipleResultsFound</code></td>
        </tr>
    </tbody>
</table>

<p>Essayons la même requête qu’auparavant, mais au lieu d’appeler <code>.all()</code>, nous allons utiliser <code>.first()</code> pour récupérer une seule instance de <code>Entry</code> :</p>
<pre><code class="language-bash">In []: entries = Entry.query.filter(Entry.title == 'titre B').first()
In []: entries
Out[]: &lt;Entry: 'titre B'&gt;
</code></pre>
<p>Notez qu’auparavant, <code>.all()</code> retournait une liste contenant l’objet, tandis que <code>.first()</code> renvoyait directement l’objet lui-même.</p>
<h3>Recherches spéciales</h3>
<p>Dans l’exemple précédent, nous avons testé une égalité, mais il existe de nombreux autres types de recherches possibles. Dans le tableau suivant, nous avons listé quelques-unes que vous pourriez trouver utiles. Vous pouvez consulter la documentation de SQLAlchemy pour obtenir la liste complète.</p>
<table>
    <caption>Exemples de requêtes SQLAlchemy avec leur signification correspondante</caption>
    <thead>
        <tr>
            <th scope="col">Exemple</th>
            <th scope="col">Signification</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Entry.title == 'The title'</td>
            <td>Entrées dont le titre est "The title", en respectant la casse (sensible à la casse).</td>
        </tr>
        <tr>
            <td>Entry.title != 'The title'</td>
            <td>Entrées dont le titre n’est pas "The title".</td>
        </tr>
        <tr>
            <td>Entry.created_timestamp &lt; datetime.date(2014, 1, 25)</td>
            <td>Entrées créées avant le 25 janvier 2014. Pour "inférieur ou égal", utilisez &lt;=.</td>
        </tr>
        <tr>
            <td>Entry.created_timestamp &gt; datetime.date(2014, 1, 25)</td>
            <td>Entrées créées avant le 25 janvier 2014. Pour "supérieur ou égal", utilisez &gt;=.</td>
        </tr>
        <tr>
            <td>Entry.body.contains('Python')</td>
            <td>Entrées dont le contenu (**body**) contient le mot **"Python"**, en respectant la casse (sensible à la casse).</td>
        </tr>
        <tr>
            <td>Entry.title.endswith('Python')</td>
            <td>Entrées dont le titre se termine par la chaîne **"Python"**, en respectant la casse (sensible à la casse). Notez que cela correspondra également à des titres se terminant par des mots comme **"CPython"**, par exemple.</td>
        </tr>
        <tr>
            <td>Entry.title.startswith('Python')</td>
            <td>Entrées dont le titre commence par la chaîne **"Python"**, en respectant la casse (sensible à la casse). Notez que cela correspondra également à des titres comme **"Pythonistas"**, par exemple.</td>
        </tr>
        <tr>
            <td>Entry.body.ilike('%python%')</td>
            <td>Entrées dont le contenu (**body**) contient le mot **"python"** n'importe où dans le texte, **sans tenir compte de la casse** (insensible à la casse).  Le caractère **`%`** est un **joker** (wildcard) qui représente n’importe quelle séquence de caractères.</td>
        </tr>
        <tr>
            <td>Entry.title.in_(['Title one', 'Title two'])</td>
            <td>Entrées dont le titre figure dans la liste donnée, c’est-à-dire **'Title one'** ou **'Title two'**.</td>
        </tr>
    </tbody>
</table>

<h3>Combinaison d’expressions</h3>
<p>Les expressions listées dans le tableau précédent peuvent être combinées à l’aide d’opérateurs binaires pour créer des expressions arbitrairement complexes.</p>
<p>Par exemple, si nous voulons récupérer tous les articles de blog dont le titre contient le mot <strong>Python</strong> ou <strong>Flask</strong>, nous allons créer deux expressions <code>contains</code>, puis les combiner avec l’opérateur binaire <strong>OR</strong> de Python, qui s’écrit avec un caractère <strong>pipe</strong> <code>|</code>, contrairement à beaucoup d’autres langages qui utilisent le double pipe <code>||</code> :</p>
<pre><code class="language-python">Entry.query.filter(Entry.title.contains('Python') | Entry.title.contains('Flask'))
</code></pre>
<p>En utilisant les opérateurs binaires, on peut créer des expressions assez complexes. Essaie de comprendre ce que demande l’exemple suivant :</p>
<pre><code class="language-python">Entry.query.filter((Entry.title.contains('Python') | Entry.title.contains('Flask')) &amp; (Entry.created_timestamp &gt; (datetime.date.today() -
datetime.timedelta(days=30))))
</code></pre>
<p>Comme vous l’avez probablement deviné, cette requête renvoie toutes les entrées dont le titre contient soit <strong>Python</strong> soit <strong>Flask</strong>, et qui ont été créées au cours des 30 derniers jours. Nous utilisons les opérateurs binaires <strong>OR</strong> et <strong>AND</strong> de Python pour combiner les sous-expressions.</p>
<p>Pour toute requête que vous construisez, vous pouvez afficher le SQL généré en imprimant la requête de la manière suivante :</p>
<pre><code class="language-bash">In []: entries = Entry.query.filter(Entry.slug.contains('test'))
In []: print(str(entries))
SELECT entry.id AS entry_id, entry.title AS entry_title, entry.slug AS entry_slug, entry.body AS entry_body, entry.created_timestamp AS entry_created_timestamp, entry.modified_timestamp AS entry_modified_timestamp 
FROM entry WHERE (entry.slug LIKE '%' || ? || '%')
</code></pre>
<h3>Négation</h3>
<p>Il reste une notion à aborder : la négation. Si nous voulions obtenir une liste de tous les articles de blog dont le titre ne contient ni <strong>Python</strong> ni <strong>Flask</strong>, comment ferions-nous ? SQLAlchemy offre deux façons de créer ce type d’expressions : en utilisant soit l’opérateur unaire de négation de Python (<code>~</code>), soit en appelant <code>db.not_()</code>. Voici comment construire cette requête avec SQLAlchemy :</p>
<pre><code class="language-python">Entry.query.filter(~(Entry.title.contains('Python') | Entry.title.contains('Flask')))
Entry.query.filter(db.not_(Entry.title.contains('Python') | Entry.title.contains('Flask')))
</code></pre>
<h3>Priorité des opérateurs</h3>
<p>Toutes les opérations ne sont pas traitées de la même manière par l’interpréteur Python. C’est un peu comme en mathématiques, où l’on apprend que l’expression <code>2 + 3 * 4</code> vaut <code>14</code> et non <code>20</code>, car la multiplication est effectuée avant l’addition. En Python, les opérateurs bit à bit ont une priorité plus élevée que, par exemple, les tests d’égalité. Cela signifie que, lorsque vous construisez votre expression de requête, il faut faire attention à bien utiliser les parenthèses. Regardons quelques exemples d’expressions Python et leurs requêtes correspondantes :</p>
<table>
    <caption>Exemples d’expressions SQLAlchemy et leurs résultats en fonction de la priorité des opérateurs</caption>
    <thead>
        <tr>
            <th scope="col">Expression</th>
            <th scope="col">Résultat</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>(Entry.title == 'Python' | Entry.title == 'Flask')</td>
            <td>Faux ! SQLAlchemy génère une erreur parce que la première chose évaluée est en réalité 'Python' | Entry.title !</td>
        </tr>
        <tr>
            <td>(Entry.title == 'Python') | (Entry.title == 'Flask')</td>
            <td>Exact. Retourne les entrées dont le titre est soit « Python » soit « Flask ».</td>
        </tr>
        <tr>
            <td>~Entry.title == 'Python'</td>
            <td>Faux ! SQLAlchemy va transformer cela en une requête SQL valide, mais les résultats ne seront pas pertinents.</td>
        </tr>
        <tr>
            <td>~(Entry.title == 'Python')</td>
            <td>Exact. Retourne les entrées dont le titre n’est pas égal à « Python ».</td>
        </tr>
    </tbody>
</table>

<p>Si vous avez du mal avec la priorité des opérateurs, il est prudent de mettre des parenthèses autour de toute comparaison utilisant <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> et <code>&gt;=</code>.</p>
<h2>Créer un système de tags</h2>
<p>Les tags sont un système de taxonomie léger, parfaitement adapté aux blogs. Ils permettent d’attribuer plusieurs catégories à un article de blog et de relier plusieurs articles entre eux, indépendamment de leur catégorie principale. Sur mon propre blog, j’utilise les tags pour organiser les articles, de sorte que les personnes intéressées par mes publications sur Flask puissent simplement consulter le tag « Flask » et trouver tous les articles pertinents.</p>
<p>Comme indiqué dans les spécifications abordées au <a href="/articles/flask-chapitre-2-preparation-du-projet-de-blog-14.html">Chapitre 2, « Préparation du projet de blog »</a>, chaque article de blog peut avoir autant ou aussi peu de tags que vous le souhaitez. Ainsi, un article sur Flask peut être étiqueté à la fois avec les tags « Flask » et  « Python ». De même, chaque tag (par exemple <em>Python</em>) peut être associé à plusieurs articles. En termes de base de données, cela s’appelle une <strong>relation plusieurs-à-plusieurs</strong> (<em>many-to-many</em>).</p>
<p>Pour modéliser cela, nous devons d’abord créer un modèle pour stocker les tags. Ce modèle contiendra les noms des tags que nous utilisons, donc après en avoir ajouté quelques-uns, la table pourrait ressembler à celle-ci :</p>
<table>
  <caption>Données de la table Tags</caption>
  <thead>
    <tr>
      <th scope="col">id</th>
      <th scope="col">tag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Python</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Flask</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Django</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Divers</td>
    </tr>
  </tbody>
</table>

<p>Ouvrons le fichier <code>models.py</code> et ajoutons une définition pour le modèle <code>Tag</code>. Ajoutez la classe suivante à la fin du fichier, en dessous de la classe <code>Entry</code> :</p>
<pre><code class="language-python">class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64), unique=True)

    def __init__(self, *args, **kwargs):
        super(Tag, self).__init__(*args, **kwargs)
        self.slug = slugify(self.name)

    def __repr__(self):
        return '&lt;Tag %r&gt;' % self.name
</code></pre>
<p>Vous avez déjà vu tout cela auparavant. Nous avons ajouté une clé primaire, qui sera gérée par la base de données, ainsi qu’une seule colonne pour stocker le nom du tag. La colonne <code>name</code> est marquée comme unique, ce qui signifie que chaque tag ne sera représenté que par une seule ligne dans cette table, peu importe le nombre d’articles de blog auxquels il est associé.</p>
<p>Maintenant que nous avons des modèles pour les articles de blog et pour les tags, nous avons besoin d’un troisième modèle pour stocker les relations entre les deux (relation n*n). Lorsque nous voulons indiquer qu’un article est associé à un tag particulier, nous stockons une référence dans cette table. </p>
<p>Comme nous n’accéderons jamais directement à cette table intermédiaire (SQLAlchemy la gérera de manière transparente pour nous), nous ne créerons pas de modèle pour celle-ci, mais nous allons simplement définir une table pour stocker la correspondance. Ouvrez le fichier <code>models.py</code> et ajoutez le code suivant :</p>
<p><strong>au dessus de la class <code>Entry</code></strong> :</p>
<pre><code class="language-python">entry_tags = db.Table('entry_tags',
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id')),
    db.Column('entry_id', db.Integer, db.ForeignKey('entry.id'))
)
</code></pre>
<p>**dans la class <code>Entry</code> au dessus de la méthode <code>__init__</code> : </p>
<pre><code class="language-python">tags = db.relationship('Tag', secondary=entry_tags, backref=db.backref('entries', lazy='dynamic'))
</code></pre>
<p>Le fichier  <code>models.py</code> devrait être comme ceci: </p>
<pre><code class="language-python">import datetime, re
from app import db


def slugify(s):
    return re.sub('[^\w]+', '-', s).lower()


entry_tags = db.Table('entry_tags',
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id')),
    db.Column('entry_id', db.Integer, db.ForeignKey('entry.id'))
)

class Entry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    _title = db.Column('title', db.String(255))
    slug = db.Column(db.String(255), unique=True)
    body = db.Column(db.Text)
    created_timestamp = db.Column(db.DateTime, default=datetime.datetime.now)
    modified_timestamp = db.Column(db.DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)

    @property
    def title(self):
        return self._title

    @title.setter
    def title(self, value):
        self._title = value
        self.slug = slugify(value) if value else ''

    def __init__(self, *args, **kwargs):
        super(Entry, self).__init__(*args, **kwargs)
        if 'title' in kwargs:
            self.slug = slugify(kwargs['title'])
        else:
            self.slug = ''

    def __repr__(self):
        return '&lt;Entry: %r&gt;' % self.title


class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64))
    slug = db.Column(db.String(64), unique=True)

    def __init__(self, *args, **kwargs):
        super(Tag, self).__init__(*args, **kwargs)
        self.slug = slugify(self.name)

    def __repr__(self):
        return '&lt;Tag %r&gt;' % self.name
</code></pre>
<p>En créant la table <code>entry_tags</code>, nous avons établi un lien entre les modèles <code>Entry</code> et <code>Tag</code>. SQLAlchemy fournit une API de haut niveau pour gérer cette relation, via la fonction bien nommée <code>db.relationship</code>. Cette fonction crée une nouvelle propriété sur le modèle <code>Entry</code> qui nous permet de lire et d’écrire facilement les tags associés à un article de blog donné. Ces deux lignes de code font beaucoup de choses, alors examinons-les de plus près :</p>
<pre><code class="language-python">tags = db.relationship('Tag', secondary=entry_tags, backref=db.backref('entries', lazy='dynamic'))
</code></pre>
<p>Nous définissons l’attribut <code>tags</code> de la classe <code>Entry</code> comme étant égal à la valeur retournée par la fonction <code>db.relationship</code>. Les deux premiers arguments, <code>'Tag'</code> et <code>secondary=entry_tags</code>, indiquent à SQLAlchemy que nous allons interroger le modèle <code>Tag</code> via la table <code>entry_tags</code>. Le troisième argument crée une <strong>référence inverse</strong>, ce qui nous permet de passer du modèle <code>Tag</code> à la liste des articles de blog associés. En spécifiant <code>lazy='dynamic'</code>, nous demandons à SQLAlchemy de ne pas charger immédiatement tous les articles associés, mais de nous fournir à la place un objet <code>Query</code>.</p>
<h3>Ajouter et supprimer des tags des entrées</h3>
<p>Utilisons le shell IPython pour voir comment cela fonctionne. Fermez votre shell actuel et relancez le script <code>script_create_db.py</code>. Cette étape est nécessaire car nous avons ajouté deux nouvelles tables. Maintenant, rouvrez IPython :</p>
<pre><code class="language-bash">(.venv) $ python script_create_db.py
(.venv) $ ipython
In []: from models import *
In []: from main import *
In []: Tag.query.all()
Out[]: []
</code></pre>
<p>Il n'y a actuellement aucun tag dans la base de données, alors créons-en quelques-uns :</p>
<pre><code class="language-bash">In []: python = Tag(name='python')
In []: flask = Tag(name='flask')
In []: db.session.add_all([python, flask])
In []: db.session.commit()
</code></pre>
<p>Chargeons maintenant quelques entrées d'exemple. Dans ma base de données, il y en a quatre :</p>
<pre><code class="language-bash">In []: entries = Entry.query.all()
In []: entries
Out[]: 
[&lt;Entry: 'python article'&gt;,
 &lt;Entry: 'flask article'&gt;,
 &lt;Entry: 'un autre article flask'&gt;,
 &lt;Entry: 'Django article'&gt;]
 In []: python_entry, flask_entry, more_flask, django_entry = entries
</code></pre>
<p>Pour ajouter des tags à une entrée, il suffit de les assigner à l’attribut <code>tags</code> de l’entrée. C’est aussi simple que ça !</p>
<pre><code class="language-bash">In []: python_entry.tags = [python]   
In []: flask_entry.tags = [python, flask]
In []: db.session.commit()
</code></pre>
<p>Nous pouvons manipuler la liste de tags d’une entrée comme une liste Python classique, donc les méthodes habituelles <code>.append()</code> et <code>.remove()</code> fonctionneront également.</p>
<pre><code class="language-bash">In []: pandas = Tag(name='pandas')
In []: python_entry.tags.append(pandas)
In []: db.session.commit()
In []: python_entry.tags
Out[]: [&lt;Tag python&gt;, &lt;Tag pandas&gt;]
In []: python_entry.tags.remove(pandas)
In []: db.session.commit()
In []: python_entry.tags
Out[]: [&lt;Tag python&gt;]
</code></pre>
<h3>Utilisation des références inversées</h3>
<p>Lorsque nous avons créé l’attribut <code>tags</code> dans le modèle <code>Entry</code>, vous vous souvenez que nous avons passé un argument <code>backref</code>. Utilisons IPython pour voir comment la référence inversée est utilisée.</p>
<pre><code class="language-bash">In []: python
Out[]: &lt;Tag python&gt;
In []: python.entries
Out[]: &lt;sqlalchemy.orm.dynamic.AppenderQuery at 0x7f614cd7cac0&gt;
In []: python.entries.all()
Out[]: [&lt;Entry: 'python entry'&gt;, &lt;Entry: 'flask entry'&gt;]
</code></pre>
<p>Contrairement à la référence <code>Entry.tags</code>, la référence inverse est spécifiée avec <code>lazy='dynamic'</code>. Cela signifie que, contrairement à <code>entry.tags</code>, qui renvoie une liste de tags, nous ne recevrons pas une liste d'entrées chaque fois que nous accédons à <code>tag.entries</code>. Pourquoi ? En général, lorsque le résultat contient plus que quelques éléments, il est plus utile de traiter la référence inverse comme une requête, que l’on peut filtrer, trier, etc. Par exemple, que faire si l’on souhaite afficher la dernière entrée taguée avec "python" ?</p>
<pre><code class="language-bash">In []: python.entries.order_by(Entry.created_timestamp.desc()).first()
Out[]: &lt;Entry: 'flask entry'&gt;
</code></pre></div>
      <p class="text-right">Publié le <time datetime="25-06-10">10 juin 2025</time></p>
    </article>
  </section>
  <section id="lateralBar">
    <div>
      <button type="button" class="button" id="tableOfContent" data-panel="true" data-panel-target="#summary">
        <span class="fa-solid fa-list"></span>
        <span class="hide">Table de contenu</span>
      </button>
      <button type="button" class="button" id="tableOfContent" data-panel="true" data-panel-target="#search">
        <span class="fa-solid fa-magnifying-glass"></span>
        <span class="hide">Chercher</span>
      </button>
      <ul class="flex-container flex-dir-column no-bullet share">
        
          <li>
            <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html&amp;title=Flask%20-%20Chapitre%203%20%3A%20Bases%20de%20donn%C3%A9es%20relationnelles%20avec%20SQLAlchemy&amp;source=http%3A//rb-webstudio.go.yj.fr" class="button" target="_blank" rel="noopener noreferrer">
              <span class="fa-brands fa-linkedin-in"></span>
              <span class="hide">Partager sur Linkedin</span>
            </a>
          </li>
        
          <li>
            <a href="https://twitter.com/intent/tweet?url=http%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html&amp;text=Flask%20-%20Chapitre%203%20%3A%20Bases%20de%20donn%C3%A9es%20relationnelles%20avec%20SQLAlchemy" class="button" target="_blank" rel="noopener noreferrer">
              <span class="fa-brands fa-x-twitter"></span>
              <span class="hide">Partager sur Twitter</span>
            </a>
          </li>
        
          <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html" class="button" target="_blank" rel="noopener noreferrer">
              <span class="fa-brands fa-facebook"></span>
              <span class="hide">Partager sur Facebook</span>
            </a>
          </li>
        
          <li>
            <a href="mailto:?subject=Je%20souhaite%20te%20partager%20cet%20article%20%3A%20Flask%20-%20Chapitre%203%20%3A%20Bases%20de%20donn%C3%A9es%20relationnelles%20avec%20SQLAlchemy&amp;body=Salut%2C%0AJe%20pense%20que%20cet%20article%20devrait%20t%27int%C3%A9resser%20%3A%0Ahttps%3A//rb-webstudio.go.yj.fr/articles/flask-chapitre-3-bases-de-donnees-relationnelles-avec-sqlalchemy-16.html" class="button" target="_blank" rel="noopener noreferrer">
              <span class="fa-solid fa-share-nodes"></span>
              <span class="hide">Partager à un ami</span>
            </a>
          </li>
        
      </ul>
    </div>
    <div>
      <button class="button changeMode" aria-label="Activer le mode sombre">
        <span class="fa-solid fa-moon"><span class="text">Activer le mode sombre</span></span>
      </button>
      <a class="button" id="goToTop" href="#top" aria-label="Retour en haut de la page"><i class="fa-solid fa-arrow-up"></i></a>
    </div>
  </section>
  <aside class="layer" id="search">
    <div class="wrap">
      <button class="button close" aria-label="fermer le panneau">
        <span class="fa-solid fa-xmark"></span>
      </button>
      <div class="content">
        <h2><strong>Rechercher</strong></h2>
        <form action="/services/articles/search.html" method="get" role="search" class="grid-x grid-padding-x">
          <label class="cell medium-9 small-10">
            <input type="search" name="q" aria-label="saisir votre recherche" placeholder="Entrez vos mots-clés">
          </label>
          <div class="cell medium-3 small-2">
              <button type="submit" aria-label="envoyer" class="button">
                <span class="fa-solid fa-magnifying-glass"></span>
              </button>
          </div>
        </form>
        <output></output>
        <div id="resultSearch" aria-live="polite" aria-atomic="true"></div>
      </div>
    </div>
  </aside>
  <aside class="layer" id="summary">
    <div class="wrap">
      <button class="button close" aria-label="fermer le panneau">
        <span class="fa-solid fa-xmark"></span>
      </button>
      <div class="content">
        <h2><strong>Table des matières</strong></h2>
        <nav></nav>
      </div>
    </div>
  </aside>
  <script type="text/template" id="tplProgressFalse">
    <div id="progressFalse">
      <div id="cursorProgress">&nbsp;</div>
    </div>
  </script>
  <script type="text/template" id="tplLayer">
      <ul class="no-bullet">
        [[ for(let row of rows){ ]]
          <li><a href="[[- row.url]]">[[= row.text ]]</a></li>
        [[ } ]]
      </ul>
  </script>


      <section class="contact" id="contact">
  <h3>me contacter</h3>
  <div class="content">
    <p class="info">
      <small><em><span>*</span> champ obligatoire</em></small>
    </p>
    <form id="formContact" action="/services/mail/send.html" method="post" class="grid-x grid-padding-x clearfix" novalidate>
      <label class="cell medium-4 padding-left-0">
        <span>
          <span>Civilité</span>
          <select name="civility" required data-validate-rules="isnotempty" data-error-isnotempty="ne doit pas être vide">
            <option value="">choisir</option>
            <option value="Mademoiselle">Mademoiselle</option>
            <option value="Madame">Madame</option>
            <option value="Monsieur">Monsieur</option>
          </select>
        </span>
      </label>
      <label class="cell medium-4">
        <span>
          <span>Prénom</span>
          <input type="text" name="firstname">
        </span>
      </label>
      <label class="cell medium-4 padding-right-0">
        <span>
          <span>Nom</span>
          <input type="text" name="lastname" required data-validate-rules="isnotempty isminlength" data-error-isnotempty="ne doit pas être vide" data-error-isminlength="doit avoir minimum 3 caractères" data-validate-isminlength-args="3">
        </span>
      </label>
      <label class="cell medium-6 margin-top-1 padding-left-0">
        <span>
          <span>Email</span>
          <input type="email" name="email" required data-validate-rules="isnotempty isemail" data-error-isnotempty="ne doit pas être vide" data-error-isemail="Ce champ doit avoir la bonne saisie (dom@dom.com)">
        </span>
      </label>
      <label><span><span>addresse</span><input type="text" name="address" tabindex="-1"></span></label>
      <label class="cell medium-6 padding-right-0 margin-top-1">
        <span>
          <span>Sujet</span>
          <input type="text" name="subject" required data-validate-rules="isnotempty isminlength" data-error-isnotempty="ne doit pas être vide" data-error-isminlength="doit avoir minimum 3 caractères" data-validate-isminlength-args="3">
        </span>
      </label>
      <label class="cell medium-3 flex-container align-middle">
        <span>
          <input type="checkbox" name="appointement">
          <span class="icon">
            <i class="fa-regular fa-square"></i>
            <i class="fa-solid fa-square-check"></i>
          </span>
          <span class="margin-left-1">un rendez-vous</span>
        </span>
      </label>
      <label class="cell medium-3"><span><span>Téléphone</span><input type="text" name="phone" disabled data-validate-rules="isnotempty checkphone" data-error-isnotempty="le n° de téléphone est manquant" data-error-checkphone="Le format du champ téléphone ne semble pas être bon 0102030405" data-validate-target-error="#errorAppointment"></span></label>
      <label class="cell medium-3"><span><span>Date</span><input type="date" name="date_appointment" disabled data-validate-rules="isnotempty datemin businessday isdate" data-error-isnotempty="la date est manquante" data-error-datemin="La date de rendez vous doit être suppérieur à aujourd'hui" data-error-businessday="les rendez vous sont du lundi au vendredi" data-error-isdate="Ce champ doit être une date valide" data-validate-target-error="#errorAppointment"></span></label>
      <label class="cell medium-3"><span><span>Heure</span><input type="time" name="hour_appointment" disabled data-validate-rules="isnotempty betweenhour" data-error-isnotempty="l'heure est manquante" data-error-betweenhour="Les rendez vous sont compris entre 9 h 00 et 18 h 00" data-validate-target-error="#errorAppointment" data-validate-betweenhour-args="9;18"></span></label>
      <div id="errorAppointment" class="cell medium-12"></div>
      <label class="cell medium-12"><span><span>Message</span><textarea name="message" cols="30" rows="10" required data-validate-rules="isnotempty isminlength" data-error-isnotempty="ne doit pas être vide" data-error-isminlength="doit avoir minimum 3 caractères" data-validate-isminlength-args="3"></textarea></span></label>
      <div class="cell medium-4 margin-top-1 large-offset-8">
        <button class="button expanded" type="submit">envoyer</button>
      </div>
    </form>
  </div>
</section>
      <footer>
  <p class="flex-container align-middle align-justify">
  <span>RB webstudio &ndash; <a href="https://www.alsacreations.com/profil/lire/11496-niuxe.html" target="_blank">Alsacreations</a> &ndash; <a href="https://github.com/niux3" target="_blank">Github</a> &ndash; <a href="https://www.linkedin.com/in/renaud-bourdeau-%F0%9F%90%A7-7639b944/" target="_blank">LinkedIn</a> &ndash; <a href="/static/renaud-bourdeau-cv.pdf">CV</a></span>
  
  </p>
</footer>

    </main>
    <script src="/static/app-CGkp-oT6.js"></script>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
      <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MCT7LV9P" height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>
    <!-- End Google Tag Manager (noscript) -->
  </body>
</html>